\section{DIS 1B}

\subsection{Stable Matching}

Cool application of induction. 

\subsubsection{The Propose and Reject Algorithm}

Suppose jobs proposes to candidates. 

\begin{itemize}
    \item both jobs and candidates have a list of preferences 
    \item every day a job that doesn't have a deal with a candidate will propose to the next best candidate on its preference list
    \item every candidate will tentatively ``waitlist'' the offer from the job (put it on a string)
    \item if a candidate has multiple offers, they will choose the one they prefer the most
    \item the algorithm ends when every candidate has a job on their ``waitlist'' (all these WLs becomes acceptances)
\end{itemize}

(walk through q1 of dis as a class to visualize this)

\subsubsection{Stability}
\begin{definition}[Rogue Couple]
    A job-candidate pair $(J,C)$ is denoted as a \textbf{rogue couple} if they prefer each other over their final assignment in a stable matching instance. 
\end{definition}

\begin{definition}[Unstable]
    A matching that has at least one rogue couple is considered \textbf{unstable}.
\end{definition}

Conversely, a \textbf{stable} matching is one that has no rogue couples. 

Some tricky vocab stuff like stable matching instance. 

\begin{lemma}[Improvement]
    If a candidate has a job offer, then they will always have an offer from a job at least as good as the one they have right now. 
\end{lemma}

Matchings produced by the algorithm are always \textbf{stable}. 

\subsubsection{Optimality}

The propose and reject algorithm is proposer \textit{optimal} and receiver \textit{pessimal}.

\begin{definition}[optimal]
    A pairing is optimal for a group if each entity is paired with who it most prefers  while maintaining stability. 
\end{definition}

Can be thought of a (well that's the best I could do) analogy. 

\begin{definition}[pessimal]
    A pairing is pessimal for a group if each entity is paired with who it least prefers while maintaining stability.
\end{definition}

Can be thought of a (well it can't get worse than this) analogy. 

\subsubsection{Potpourri}
It is possible that there exists a stable matching instance that is neither job optimal nor candidate pessimal. 

Consider the following preferences

\[\begin{array}{|c|c|}
    \hline
    \text{Jobs} & \text{Preferences} \\
    \hline
    A & 1 > 2 > 3 \\
    \hline 
    B & 2 > 3 > 1\\
    \hline
    C & 3 > 1 > 2\\
    \hline
\end{array}
    \qquad 
    \begin{array}{|c|c|}
        \hline
        \text{Candidates} & \text{Preferences} \\
        \hline
        1 & B > C > A  \\
        \hline 
        2 & C > A > B \\
        \hline
        3 & A > B > C \\
        \hline
    \end{array}\]  

The matching above can generate (at least) 3 stable matching instances \begin{align*}
    S &= \{(A,1), (B,2), (C,3)\} \\
    T &= \{(A,3), (B,1), (C,2)\} \\
    U &= \{(A,2), (B,3), (C,1)\}. 
\end{align*}

We see \begin{itemize}
    \item $S$ is job-optimal/candidate-pessimal (result of running propose and reject with jobs proposing to candidates)
    \item $T$ is candidate-optimal/job-pessimal (result of running propose and reject with candidates proposing to jobs)
    \item $U$ is neither optimal nor pessimal for both candidates and jobs ($S$ and $T$) corroborate that. 
\end{itemize}

Also some other important facts that can be seen (from discussion worksheet questions):
\begin{itemize}
    \item There is at least one job that will receive only one proposal (that too on the last day)
    \item We can upper bound the number of days needed by P\&R algorithm to $(n-1)^2 + 1 = n^2-2n+2$ (think about why)
    \item As a consequence of above, we can upper bound the number of rejections needed by P\&R algorithm to $(n-1)^2  = n^2 - 2n + 1$ rejections. 
\end{itemize}